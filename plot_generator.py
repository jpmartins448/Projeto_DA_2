# plot_generator.py
#
# Purpose:
# This script generates a series of plots to visualize the performance and accuracy
# data collected by data_collector.py. It reads the 'performance_results.csv' file
# and creates PNG image files for runtime comparisons, profit achievements, and
# profit accuracy relative to optimal solutions.
#
# How to Run:
# python plot_generator.py
#
# Dependencies:
# - Python 3.x
# - pandas library (install with: pip install pandas)
# - matplotlib library (install with: pip install matplotlib)
# - seaborn library (install with: pip install seaborn)
#
# Expected Input File (must be in the same directory as this script):
# - performance_results.csv: CSV file generated by data_collector.py, containing
#   the performance metrics of different optimization algorithms.
#
# Output Files (saved in the same directory):
# - runtime_comparison.png: Bar chart comparing runtimes of different algorithms.
# - profit_comparison.png: Bar chart comparing achieved profits, with optimal profit overlaid.
# - accuracy_percentage_comparison.png: Bar chart showing profit accuracy as a percentage of optimal.

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np # Used for NaN representation and numeric operations

def clean_data(df):
    """
    Cleans the input DataFrame:
    1. Converts specified columns to numeric types, coercing errors to NaN.
       (Errors might be strings like 'Timeout', 'CompilationFailed' from data_collector.py)
    2. Calculates 'accuracy_percentage' from 'profit_achieved' and 'optimal_profit'.
    3. Sorts the DataFrame by a numeric representation of 'problem_id' for consistent plot ordering.
    4. Prints warnings or info messages if essential columns are missing or contain many NaNs.
    """
    print("Cleaning data from loaded CSV...")
    
    # Columns that are expected to contain numerical data for plotting
    numeric_cols = ['runtime', 'profit_achieved', 'optimal_profit', 'weight_achieved', 'optimal_weight']
    
    original_columns = df.columns.tolist() # Keep track of original columns

    for col in numeric_cols:
        if col in df.columns:
            # Convert to numeric. 'errors="coerce"' turns unparseable strings into NaN.
            df[col] = pd.to_numeric(df[col], errors='coerce')
        else:
            # If a numeric column is entirely missing, add it as a column of NaNs.
            # This allows downstream plotting functions to check for its existence
            # and skip related plots gracefully, rather than failing with a KeyError.
            print(f"Warning: Expected numeric column '{col}' not found in CSV. Plots involving it may be affected.")
            df[col] = np.nan 

    # Calculate profit accuracy: (achieved_profit / optimal_profit) * 100
    # This requires 'profit_achieved' and 'optimal_profit' to be numeric (or NaN).
    if 'profit_achieved' in df.columns and 'optimal_profit' in df.columns:
        # Calculate only where optimal_profit is not NaN and not zero to avoid division errors or meaningless results.
        # Also ensure profit_achieved is not NaN.
        df['accuracy_percentage'] = np.where(
            (df['optimal_profit'].notna()) & (df['optimal_profit'] != 0) & (df['profit_achieved'].notna()),
            (df['profit_achieved'] / df['optimal_profit']) * 100,
            np.nan # Result is NaN if conditions are not met
        )
    else:
        print("Warning: 'profit_achieved' or 'optimal_profit' columns are missing or fully NaN after conversion. Cannot calculate 'accuracy_percentage'.")
        df['accuracy_percentage'] = np.nan # Ensure column exists even if it can't be calculated

    # Sort data by problem_id to ensure plots have a consistent and logical order.
    # Assumes problem_id is like 'P5', 'P10', etc. Extracts numeric part for sorting.
    if 'problem_id' in df.columns:
        # Create a temporary column for numeric sorting of problem_id
        df['problem_id_numeric_sort_temp'] = df['problem_id'].astype(str).str.extract('(\d+)', expand=False).astype(float)
        # Sort by this numeric ID, then by method_name for consistent grouping in plots
        df = df.sort_values(by=['problem_id_numeric_sort_temp', 'method_name'])
        # The temporary sort column can be dropped if not needed later, but keeping it might be useful
        # df = df.drop(columns=['problem_id_numeric_sort_temp']) 
    else:
        print("Warning: 'problem_id' column not found. Plots will not be sorted by problem ID.")
        # Add a placeholder problem_id if missing, to prevent KeyErrors in plotting functions
        if 'problem_id' not in df.columns: df['problem_id'] = 'UnknownProblem'


    # Ensure 'method_name' column exists, as it's used for 'hue' in plots.
    if 'method_name' not in df.columns:
        print("Warning: 'method_name' column not found. Using a placeholder value.")
        df['method_name'] = 'UnknownMethod'
    
    # Optional: Print info about NaN counts in key columns after cleaning.
    # This helps diagnose issues if plots are empty or missing data.
    print("NaN counts after cleaning:")
    for col in numeric_cols + ['accuracy_percentage']: # Check original numeric cols and new accuracy col
        if col in df.columns: # Check if column exists (it should, due to handling above)
            nan_count = df[col].isna().sum()
            if nan_count > 0:
                print(f"  Column '{col}': {nan_count} NaN values out of {len(df)} rows.")
    
    return df

def generate_runtime_plot(df):
    """Generates and saves a bar chart comparing runtimes of different methods per problem ID."""
    print("Attempting to generate runtime comparison plot...")
    
    # Essential columns for this plot. If missing or all values are NaN, skip.
    required_cols = ['problem_id', 'runtime', 'method_name']
    if not all(col in df.columns for col in required_cols) or df[required_cols].isna().all().any():
        print("Skipping runtime plot: One or more essential columns ('problem_id', 'runtime', 'method_name') are missing or contain only NaN values.")
        return

    plt.figure(figsize=(12, 7)) # Set figure size for better readability
    
    # Filter out any remaining rows where essential data for this plot is NaN
    plot_df = df.dropna(subset=['runtime', 'problem_id', 'method_name'])
    if plot_df.empty:
        print("Skipping runtime plot: No valid data remains after removing rows with NaN in 'runtime', 'problem_id', or 'method_name'.")
        plt.close() 
        return

    try:
        # Create the bar plot using seaborn
        sns.barplot(x='problem_id', y='runtime', hue='method_name', data=plot_df, palette='viridis')
        
        # Set plot title and labels
        plt.title('Runtime Comparison by Problem Instance', fontsize=16)
        plt.xlabel('Problem ID', fontsize=12)
        plt.ylabel('Runtime (seconds)', fontsize=12)
        plt.xticks(rotation=45, ha='right') # Rotate x-axis labels for readability
        plt.legend(title='Method') # Add legend with a title
        plt.grid(axis='y', linestyle='--', alpha=0.7) # Add a horizontal grid
        plt.tight_layout() # Adjust plot to ensure everything fits without overlapping
        
        plt.savefig('runtime_comparison.png') # Save the plot as a PNG file
        print("Successfully saved 'runtime_comparison.png'")
    except Exception as e:
        # Catch any errors during plotting or saving (e.g., if GUI backend issues in some envs)
        print(f"Error during runtime plot generation or saving: {e}")
    finally:
        plt.close() # Close the Matplotlib figure to free resources


def generate_profit_plot(df):
    """
    Generates and saves a plot comparing achieved profits of different methods
    against the optimal profit for each problem ID.
    Achieved profits are bars, optimal profit is a line.
    """
    print("Attempting to generate profit comparison plot...")

    required_cols = ['problem_id', 'method_name', 'profit_achieved', 'optimal_profit']
    if not all(col in df.columns for col in required_cols):
        print(f"Skipping profit plot: Missing one or more required columns: {required_cols}.")
        return

    # Data for method-achieved profits (bars)
    plot_df_methods = df.dropna(subset=['problem_id', 'method_name', 'profit_achieved'])
    # Data for optimal profits (line) - needs problem_id and optimal_profit, remove duplicates
    optimal_profits_df = df[['problem_id', 'optimal_profit', 'problem_id_numeric_sort_temp']].drop_duplicates().dropna(subset=['optimal_profit'])
    
    if plot_df_methods.empty and optimal_profits_df.empty:
        print("Skipping profit plot: No valid data for achieved or optimal profits after filtering NaNs.")
        return

    plt.figure(figsize=(14, 8)) # Larger figure size for combined plot
    try:
        # 1. Plot achieved profits as bars
        if not plot_df_methods.empty:
            sns.barplot(x='problem_id', y='profit_achieved', hue='method_name', data=plot_df_methods, palette='muted', alpha=0.8)
        else:
            print("Info: No 'profit_achieved' data to plot as bars in profit comparison.")

        # 2. Plot optimal profit as a line/point plot
        if not optimal_profits_df.empty:
            # Sort by the numeric problem ID to ensure the line connects points in the correct order
            optimal_profits_df_sorted = optimal_profits_df.sort_values('problem_id_numeric_sort_temp')
            sns.pointplot(x='problem_id', y='optimal_profit', data=optimal_profits_df_sorted, 
                          color='black', # Distinct color for optimal line
                          markers='D',    # Diamond marker
                          linestyles='--', # Dashed line
                          label='Optimal Profit (Line)', # Label for the legend
                          dodge=False) # Ensures points are centered on category, not shifted
        else:
            print("Info: No 'optimal_profit' data to plot as a line in profit comparison.")

        plt.title('Profit Comparison by Problem Instance', fontsize=16)
        plt.xlabel('Problem ID', fontsize=12)
        plt.ylabel('Profit', fontsize=12)
        plt.xticks(rotation=45, ha='right')
        
        # Consolidate legend: Get handles/labels from current axes (from barplot)
        # and add the one for the pointplot if it was drawn.
        handles, labels = plt.gca().get_legend_handles_labels()
        
        # Check if 'Optimal Profit (Line)' is already in labels (seaborn pointplot might add it)
        # If not, and we plotted it, manually add a proxy artist for the legend.
        if not optimal_profits_df.empty and 'Optimal Profit (Line)' not in labels:
            from matplotlib.lines import Line2D # For creating a custom legend handle
            handles.append(Line2D([0], [0], color='black', marker='D', linestyle='--', label='Optimal Profit (Line)'))
            labels.append('Optimal Profit (Line)')
        
        if not handles: # If no data was plotted at all
            print("Info: No data available for legend in profit plot.")
        else:
            plt.legend(handles=handles, labels=labels, title='Method / Benchmark')

        plt.grid(axis='y', linestyle='--', alpha=0.7)
        plt.tight_layout()
        plt.savefig('profit_comparison.png')
        print("Successfully saved 'profit_comparison.png'")
    except Exception as e:
        print(f"Error during profit plot generation or saving: {e}")
    finally:
        plt.close()


def generate_accuracy_plot(df):
    """
    Generates and saves a bar chart comparing profit accuracy 
    (achieved_profit / optimal_profit) * 100% for each method and problem ID.
    """
    print("Attempting to generate accuracy percentage comparison plot...")
    
    required_cols = ['problem_id', 'accuracy_percentage', 'method_name']
    # Check if 'accuracy_percentage' column exists and if all required columns have some non-NaN data
    if 'accuracy_percentage' not in df.columns or df[required_cols].isna().all().any():
        print("Skipping accuracy plot: 'accuracy_percentage' column not available, or essential columns ('problem_id', 'method_name') are missing/all-NaN.")
        return

    plt.figure(figsize=(12, 7))
    
    # Filter out rows where accuracy_percentage is NaN for this specific plot
    plot_df = df.dropna(subset=['accuracy_percentage', 'problem_id', 'method_name'])
    if plot_df.empty:
        print("Skipping accuracy plot: No valid data for 'accuracy_percentage' after filtering NaNs.")
        plt.close()
        return
        
    try:
        sns.barplot(x='problem_id', y='accuracy_percentage', hue='method_name', data=plot_df, palette='plasma')
        
        plt.title('Profit Accuracy (% of Optimal) by Problem Instance', fontsize=16)
        plt.xlabel('Problem ID', fontsize=12)
        plt.ylabel('Accuracy (% of Optimal Profit)', fontsize=12)
        
        # Set Y-axis limits. Allow for slightly >100% if some methods overachieve (e.g. due to different optimal definitions)
        # or if optimal is very low. Add a small buffer above the max observed accuracy if it's > 100.
        max_observed_accuracy = plot_df['accuracy_percentage'].max() if not plot_df['accuracy_percentage'].empty else 100
        upper_y_limit = max(115, max_observed_accuracy + 5 if pd.notna(max_observed_accuracy) else 115)
        plt.ylim(0, upper_y_limit)
        
        # Add a horizontal line at 100% to represent perfect accuracy
        plt.axhline(100, color='grey', linestyle='--', label='100% Optimal Line')
        plt.xticks(rotation=45, ha='right')
        
        # Consolidate legend for methods and the 100% optimal line
        handles, labels = plt.gca().get_legend_handles_labels()
        if '100% Optimal Line' not in labels: # If axhline didn't add its label (it usually doesn't by default)
            from matplotlib.lines import Line2D
            handles.append(Line2D([0], [0], color='grey', linestyle='--', label='100% Optimal Line'))
            labels.append('100% Optimal Line')

        if not handles:
            print("Info: No data available for legend in accuracy plot.")
        else:
            plt.legend(handles=handles, labels=labels, title='Method')
            
        plt.grid(axis='y', linestyle='--', alpha=0.7)
        plt.tight_layout()
        plt.savefig('accuracy_percentage_comparison.png')
        print("Successfully saved 'accuracy_percentage_comparison.png'")
    except Exception as e:
        print(f"Error during accuracy plot generation or saving: {e}")
    finally:
        plt.close()

def main():
    """
    Main function to drive the plot generation process:
    1. Loads data from 'performance_results.csv'.
    2. Cleans and prepares the data.
    3. Calls functions to generate and save each required plot.
    """
    csv_file = 'performance_results.csv'
    try:
        df = pd.read_csv(csv_file)
        print(f"Successfully loaded '{csv_file}'")
        if df.empty:
            print(f"The file '{csv_file}' is empty. No data to plot. Exiting.")
            return
    except FileNotFoundError:
        print(f"Error: The file '{csv_file}' was not found. Please ensure 'data_collector.py' was run first and generated this file.")
        return
    except pd.errors.EmptyDataError: # Technically covered by df.empty, but good for explicit handling
        print(f"Error: The file '{csv_file}' is empty (possibly only headers). No data to plot. Exiting.")
        return
    except Exception as e: # Catch other potential pandas read_csv errors
        print(f"An critical error occurred while reading '{csv_file}': {e}. Exiting.")
        return

    # Create a numeric sort key for problem_id if the column exists, before cleaning.
    # This ensures that the original DataFrame is sorted if 'problem_id' is present,
    # and this sort order can be maintained in `clean_data`.
    if 'problem_id' in df.columns:
        # Store the sort key directly in the DataFrame to be used by clean_data if needed
        df['problem_id_numeric_sort_temp'] = df['problem_id'].astype(str).str.extract('(\d+)', expand=False).astype(float)
        df = df.sort_values(by=['problem_id_numeric_sort_temp']) 
    else:
        # If 'problem_id' is missing, plots might not be correctly ordered or labeled.
        # clean_data will handle adding a placeholder 'problem_id' column.
        print("Warning: 'problem_id' column missing from CSV. Plots may lack meaningful x-axis labels or sorting for problems.")
        df['problem_id_numeric_sort_temp'] = 0 # Add placeholder sort key


    # Clean the data (handles type conversions, NaN, calculates accuracy)
    # Pass a copy of the DataFrame to clean_data if you want to preserve the original df.
    df_cleaned = clean_data(df.copy()) 

    # Generate each of the required plots
    generate_runtime_plot(df_cleaned)
    generate_profit_plot(df_cleaned)
    generate_accuracy_plot(df_cleaned)
    
    print("\nPlot generation process complete. Check for .png files in the script directory.")

if __name__ == '__main__':
    # Apply a seaborn theme for better aesthetics for all plots.
    # "whitegrid" is a good general-purpose theme.
    sns.set_theme(style="whitegrid")
    main() # Execute the main plotting logic
